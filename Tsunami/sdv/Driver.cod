; Listing generated by Microsoft (R) Optimizing Compiler Version 19.14.26430.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	KeyboardInputRoutine
PUBLIC	MouseInputRoutine
PUBLIC	mjRead
PUBLIC	mouIrp
PUBLIC	mouId
PUBLIC	kbdId
_DATA	SEGMENT
COMM	KbdClassReadRoutine:QWORD
COMM	MouClassReadRoutine:QWORD
COMM	MouseDpcRoutine:QWORD
COMM	KeyboardDpcRoutine:QWORD
_DATA	ENDS
_BSS	SEGMENT
KeyboardInputRoutine DQ 01H DUP (?)
MouseInputRoutine DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	KEY_DATA:BYTE:080H
COMM	MOU_DATA:BYTE:05H
_DATA	ENDS
_BSS	SEGMENT
mjRead	DQ	01H DUP (?)
mouIrp	DQ	01H DUP (?)
mouId	DD	01H DUP (?)
kbdId	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	mouTarget:QWORD
COMM	kbdTarget:QWORD
COMM	mdata:BYTE:018H
COMM	kdata:BYTE:0cH
COMM	input_mouse:QWORD
COMM	input_keyboard:QWORD
COMM	pDeviceObject:QWORD
COMM	dev:BYTE:010H
COMM	dos:BYTE:010H
_DATA	ENDS
PUBLIC	SynthesizeKeyboard
PUBLIC	SynthesizeMouse
PUBLIC	FindDevNodeRecurse
PUBLIC	KeyboardApc
PUBLIC	MouseApc
PUBLIC	ReadInstrumentation
PUBLIC	ReadInstrumentation1
PUBLIC	InvalidRequest
PUBLIC	InternalIoctl
PUBLIC	UnloadDriver
PUBLIC	CreateCall
PUBLIC	CloseCall
PUBLIC	KeReadVirtualMemory
PUBLIC	KeWriteVirtualMemory
PUBLIC	IoControl
PUBLIC	DriverEntry
PUBLIC	??_C@_0CA@LFEKFOPE@Tsunami?5load?5routine?5called?4?4?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CA@LHNAMLH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CI@LDHGHACJ@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CM@LLGPJFAO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CK@FEJCLNKG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1DA@OFKEFLHA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@KKPCHIIC@Tsunami?5loaded?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@CJALLJND@Tsunami?5unload?5routine?5called?4?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_DbgPrintEx:PROC
EXTRN	__imp_KeLowerIrql:PROC
EXTRN	__imp_KfRaiseIrql:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_IoGetCurrentProcess:PROC
EXTRN	__imp_IoGetDeviceObjectPointer:PROC
EXTRN	__imp_ObfDereferenceObject:PROC
EXTRN	__imp_PsLookupProcessByProcessId:PROC
EXTRN	MmCopyVirtualMemory:PROC
EXTRN	__C_specific_handler:PROC
EXTRN	__guard_dispatch_icall_fptr:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$SynthesizeKeyboard DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$SynthesizeKeyboard
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SynthesizeMouse DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$SynthesizeMouse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$KeyboardApc DD imagerel $LN7
	DD	imagerel $LN7+106
	DD	imagerel $unwind$KeyboardApc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MouseApc DD imagerel $LN23
	DD	imagerel $LN23+210
	DD	imagerel $unwind$MouseApc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnloadDriver DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$UnloadDriver
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateCall DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$CreateCall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CloseCall DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$CloseCall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$KeReadVirtualMemory DD imagerel $LN10
	DD	imagerel $LN10+107
	DD	imagerel $unwind$KeReadVirtualMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$KeWriteVirtualMemory DD imagerel $LN10
	DD	imagerel $LN10+107
	DD	imagerel $unwind$KeWriteVirtualMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoControl DD imagerel $LN17
	DD	imagerel $LN17+171
	DD	imagerel $unwind$IoControl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$IoControl DD imagerel $LN17+171
	DD	imagerel $LN17+331
	DD	imagerel $chain$0$IoControl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$IoControl DD imagerel $LN17+331
	DD	imagerel $LN17+369
	DD	imagerel $chain$1$IoControl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN40
	DD	imagerel $LN40+1022
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT ??_C@_0CA@CJALLJND@Tsunami?5unload?5routine?5called?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@CJALLJND@Tsunami?5unload?5routine?5called?4?6?$AA@FNODOBFM@ DB 'T'
	DB	'sunami unload routine called.', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@KKPCHIIC@Tsunami?5loaded?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@KKPCHIIC@Tsunami?5loaded?4?6?$AA@FNODOBFM@ DB 'Tsunami loaded.', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DA@OFKEFLHA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DA@OFKEFLHA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 't', 00H, 's', 00H, 'u', 00H, 'n', 00H, 'a', 00H, 'm'
	DB	00H, 'i', 00H, 'K', 00H, 'e', 00H, 'y', 00H, 'b', 00H, 'o', 00H
	DB	'a', 00H, 'r', 00H, 'd', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CK@FEJCLNKG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CK@FEJCLNKG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 't', 00H, 's', 00H, 'u', 00H, 'n', 00H, 'a', 00H, 'm'
	DB	00H, 'i', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CM@LLGPJFAO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CM@LLGPJFAO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'P', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	'0', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'K', 00H, 'e', 00H, 'y', 00H, 'b', 00H, 'o', 00H, 'a'
	DB	00H, 'r', 00H, 'd', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, '0', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CI@LDHGHACJ@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CI@LDHGHACJ@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 't', 00H, 's'
	DB	00H, 'u', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'i', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CA@LHNAMLH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CA@LHNAMLH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 't', 00H, 's', 00H, 'u', 00H, 'n', 00H, 'a', 00H, 'm'
	DB	00H, 'i', 00H, 00H, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@LFEKFOPE@Tsunami?5load?5routine?5called?4?4?4?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@LFEKFOPE@Tsunami?5load?5routine?5called?4?4?4?6?$AA@FNODOBFM@ DB 'T'
	DB	'sunami load routine called...', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 091002H
	DD	068b1604H
	DD	0600165aH
	DD	0180110H
	DD	030037004H
	DD	05002H
xdata	ENDS
;	COMDAT gfids$y
gfids$y	SEGMENT
__guard_fids_DriverEntry DDSymXIndex:  FLAT:ReadInstrumentation
	DDSymXIndex: 	FLAT:ReadInstrumentation1
	DDSymXIndex: 	FLAT:UnloadDriver
	DDSymXIndex: 	FLAT:IoControl
	DDSymXIndex: 	FLAT:CloseCall
	DDSymXIndex: 	FLAT:CreateCall
	DDSymXIndex: 	FLAT:InternalIoctl
gfids$y	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$IoControl DD 020022H
	DD	06001602H
	DD	imagerel $LN17
	DD	imagerel $LN17+171
	DD	imagerel $unwind$IoControl
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$IoControl DD 020522H
	DD	087405H
	DD	imagerel $LN17
	DD	imagerel $LN17+171
	DD	imagerel $unwind$IoControl
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoControl DD 040a02H
	DD	0a340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$KeWriteVirtualMemory DD 0a150aH
	DD	06001603H
	DD	0e7415H
	DD	0d6415H
	DD	0c3415H
	DD	0e0119215H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN10+33
	DD	imagerel $LN10+80
	DD	01H
	DD	imagerel $LN10+80
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$KeReadVirtualMemory DD 0a150aH
	DD	06001603H
	DD	0e7415H
	DD	0d6415H
	DD	0c3415H
	DD	0e0119215H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN10+33
	DD	imagerel $LN10+80
	DD	01H
	DD	imagerel $LN10+80
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CloseCall DD 030402H
	DD	06001601H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateCall DD 030402H
	DD	06001601H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnloadDriver DD 040602H
	DD	06001608H
	DD	030023206H
xdata	ENDS
;	COMDAT gfids$y
gfids$y	SEGMENT
__guard_fids_ReadInstrumentation1 DDSymXIndex:  FLAT:MouseApc
gfids$y	ENDS
;	COMDAT gfids$y
gfids$y	SEGMENT
__guard_fids_ReadInstrumentation DDSymXIndex:  FLAT:KeyboardApc
gfids$y	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MouseApc DD 030402H
	DD	06001601H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$KeyboardApc DD 040602H
	DD	06001602H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SynthesizeMouse DD 060a02H
	DD	06001602H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SynthesizeKeyboard DD 060a02H
	DD	06001602H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
;	COMDAT DriverEntry
_TEXT	SEGMENT
classNameBuffer$ = 64
deviceName$ = 80
mouname$ = 96
kbdname$ = 144
$T2 = 224
$T3 = 224
file$ = 224
pDriverObject$ = 224
pRegistryPath$ = 232
classObj$ = 240
node$ = 248
DriverEntry PROC					; COMDAT

; 152  : {

$LN40:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	57		 push	 rdi
  00004	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  00009	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00010	48 8b f9	 mov	 rdi, rcx

; 153  : 	DbgPrintEx(0, 0, "Tsunami load routine called...\n");

  00013	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CA@LFEKFOPE@Tsunami?5load?5routine?5called?4?4?4?6?$AA@FNODOBFM@
  0001a	33 c9		 xor	 ecx, ecx
  0001c	33 d2		 xor	 edx, edx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DbgPrintEx

; 154  : 
; 155  : 	RtlInitUnicodeString(&dev, L"\\Device\\tsunami");

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@LHNAMLH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dev
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 156  : 	RtlInitUnicodeString(&dos, L"\\DosDevices\\tsunami");

  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CI@LDHGHACJ@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AA?$AA@FNODOBFM@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 157  : 
; 158  : 	IoCreateDevice(pDriverObject, 0, &dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);

  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:pDeviceObject
  00053	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  00059	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0005e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:dev
  00065	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0006a	33 d2		 xor	 edx, edx
  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 159  : 	IoCreateSymbolicLink(&dos, &dev);

  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dev
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 160  : 	
; 161  : 	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = InternalIoctl;

  00091	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:InternalIoctl
  00098	48 89 87 e8 00
	00 00		 mov	 QWORD PTR [rdi+232], rax

; 162  : 	pDriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCall;
; 163  : 	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = CloseCall;
; 164  : 	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl;
; 165  : 	pDriverObject->DriverUnload = UnloadDriver;
; 166  : 
; 167  : 	pDeviceObject->Flags |= DO_DIRECT_IO;
; 168  : 	pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
; 169  : 
; 170  : 	mdata.Flags |= MOUSE_MOVE_RELATIVE;
; 171  : 
; 172  : 	// ---------- Initialize mouse and keyboard device to hijack ----------
; 173  : 	CLIENT_ID nthread;
; 174  : 	UNICODE_STRING deviceName;
; 175  : 
; 176  : 	ULONGLONG node = 0;
; 177  : 	SHORT *u;
; 178  : 	int i = 0;
; 179  : 	USHORT charBuff;
; 180  : 	wchar_t kbdname[23] = L"\\Device\\KeyboardClass0";
; 181  : 	wchar_t mouname[22] = L"\\Device\\PointerClass0";
; 182  : 	struct DEVOBJ_EXTENSION_FIX *DevObjExtension;
; 183  : 	UNICODE_STRING classNameBuffer;
; 184  : 	PDEVICE_OBJECT classObj;
; 185  : 	PDRIVER_OBJECT classDrv;
; 186  : 	PFILE_OBJECT file;
; 187  : 	MouseAddDevice MouseAddDevicePtr;
; 188  : 	KeyboardAddDevice KeyboardAddDevicePtr;
; 189  : 	HANDLE thread;
; 190  : 
; 191  : 	memset((void*)&mdata, 0, sizeof(mdata));
; 192  : 	memset((void*)&kdata, 0, sizeof(kdata));
; 193  : 	memset((void*)MOU_DATA, 0, sizeof(MOU_DATA));
; 194  : 
; 195  : 	RtlInitUnicodeString(&deviceName, L"\\Device\\tsunamiMouse");

  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@FEJCLNKG@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?$AA@FNODOBFM@
  000a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CreateCall
  000ad	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  000b1	48 8d 4d d7	 lea	 rcx, QWORD PTR deviceName$[rbp-121]
  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CloseCall
  000bc	48 89 87 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rax
  000c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:IoControl
  000ca	48 89 87 e0 00
	00 00		 mov	 QWORD PTR [rdi+224], rax
  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:UnloadDriver
  000d8	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  000dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pDeviceObject
  000e3	83 48 30 10	 or	 DWORD PTR [rax+48], 16
  000e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pDeviceObject
  000ee	81 60 30 7f ff
	ff ff		 and	 DWORD PTR [rax+48], -129 ; ffffff7fH
  000f5	8b 05 28 00 00
	00		 mov	 eax, DWORD PTR ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@+40
  000fb	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@
  00102	89 45 3f	 mov	 DWORD PTR kbdname$[rbp-81], eax
  00105	0f b7 05 2c 00
	00 00		 movzx	 eax, WORD PTR ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@+44
  0010c	0f 10 0d 10 00
	00 00		 movups	 xmm1, XMMWORD PTR ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@+16
  00113	66 89 45 43	 mov	 WORD PTR kbdname$[rbp-77], ax
  00117	8b 05 28 00 00
	00		 mov	 eax, DWORD PTR ??_C@_1CM@LLGPJFAO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@+40
  0011d	0f 11 45 17	 movups	 XMMWORD PTR kbdname$[rbp-121], xmm0
  00121	89 45 0f	 mov	 DWORD PTR mouname$[rbp-81], eax
  00124	33 c0		 xor	 eax, eax
  00126	f2 0f 10 05 20
	00 00 00	 movsd	 xmm0, QWORD PTR ??_C@_1CO@NPEEKIFM@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@+32
  0012e	f2 0f 11 45 37	 movsd	 QWORD PTR kbdname$[rbp-89], xmm0
  00133	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_1CM@LLGPJFAO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@
  0013a	48 89 05 00 00
	00 00		 mov	 QWORD PTR mdata, rax
  00141	0f 11 4d 27	 movups	 XMMWORD PTR kbdname$[rbp-105], xmm1
  00145	48 89 05 08 00
	00 00		 mov	 QWORD PTR mdata+8, rax
  0014c	0f 10 0d 10 00
	00 00		 movups	 xmm1, XMMWORD PTR ??_C@_1CM@LLGPJFAO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@+16
  00153	48 89 05 10 00
	00 00		 mov	 QWORD PTR mdata+16, rax
  0015a	0f 11 45 e7	 movups	 XMMWORD PTR mouname$[rbp-121], xmm0
  0015e	48 89 05 00 00
	00 00		 mov	 QWORD PTR kdata, rax
  00165	f2 0f 10 05 20
	00 00 00	 movsd	 xmm0, QWORD PTR ??_C@_1CM@LLGPJFAO@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA0?$AA?$AA@FNODOBFM@+32
  0016d	f2 0f 11 45 07	 movsd	 QWORD PTR mouname$[rbp-89], xmm0
  00172	0f 11 4d f7	 movups	 XMMWORD PTR mouname$[rbp-105], xmm1
  00176	89 05 08 00 00
	00		 mov	 DWORD PTR kdata+8, eax
  0017c	89 05 00 00 00
	00		 mov	 DWORD PTR MOU_DATA, eax
  00182	88 05 04 00 00
	00		 mov	 BYTE PTR MOU_DATA+4, al
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 196  : 	IoCreateDevice(pDriverObject, 0, &deviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &input_mouse);

  0018e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:input_mouse
  00195	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  0019b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001a0	4c 8d 45 d7	 lea	 r8, QWORD PTR deviceName$[rbp-121]
  001a4	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  001a9	33 d2		 xor	 edx, edx
  001ab	48 8b cf	 mov	 rcx, rdi
  001ae	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 197  : 
; 198  : 	RtlInitUnicodeString(&deviceName, L"\\Device\\tsunamiKeyboard");

  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@OFKEFLHA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAt?$AAs?$AAu?$AAn?$AAa?$AAm?$AAi?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?$AA@FNODOBFM@
  001c3	48 8d 4d d7	 lea	 rcx, QWORD PTR deviceName$[rbp-121]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 199  : 	IoCreateDevice(pDriverObject, 0, &deviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &input_keyboard);

  001cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:input_keyboard
  001d4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001d9	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  001de	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  001e4	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  001ec	4c 8d 45 d7	 lea	 r8, QWORD PTR deviceName$[rbp-121]
  001f0	33 d2		 xor	 edx, edx
  001f2	48 8b cf	 mov	 rcx, rdi
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 200  : 
; 201  : 	input_mouse->Flags |= DO_BUFFERED_IO;

  001fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR input_mouse

; 202  : 	input_mouse->Flags &= ~DO_DEVICE_INITIALIZING;
; 203  : 
; 204  : 	input_keyboard->Flags |= DO_BUFFERED_IO;
; 205  : 	input_keyboard->Flags &= ~DO_DEVICE_INITIALIZING;
; 206  : 
; 207  : 	RtlInitUnicodeString(&classNameBuffer, mouname);

  00202	48 8d 55 e7	 lea	 rdx, QWORD PTR mouname$[rbp-121]
  00206	48 8d 4d c7	 lea	 rcx, QWORD PTR classNameBuffer$[rbp-121]
  0020a	83 48 30 04	 or	 DWORD PTR [rax+48], 4
  0020e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR input_mouse
  00215	81 60 30 7f ff
	ff ff		 and	 DWORD PTR [rax+48], -129 ; ffffff7fH
  0021c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR input_keyboard
  00223	83 48 30 04	 or	 DWORD PTR [rax+48], 4
  00227	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR input_keyboard
  0022e	81 60 30 7f ff
	ff ff		 and	 DWORD PTR [rax+48], -129 ; ffffff7fH
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 208  : 	u = mouname;
; 209  : 
; 210  : 	while (1)
; 211  : 	{
; 212  : 		//run till we run out of devices or find a devnode
; 213  : 		if (IoGetDeviceObjectPointer(&classNameBuffer, FILE_ALL_ACCESS, &file, &classObj))

  0023b	4c 8d 4d 77	 lea	 r9, QWORD PTR classObj$[rbp-121]
  0023f	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  00244	4c 8d 45 67	 lea	 r8, QWORD PTR file$[rbp-121]
  00248	48 8d 4d c7	 lea	 rcx, QWORD PTR classNameBuffer$[rbp-121]
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  00252	85 c0		 test	 eax, eax
  00254	75 42		 jne	 SHORT $LN28@DriverEntr
  00256	48 8b 7d 67	 mov	 rdi, QWORD PTR $T3[rbp-121]
  0025a	66 0f 1f 44 00
	00		 npad	 6
$LL2@DriverEntr:

; 214  : 			return STATUS_OBJECT_NAME_NOT_FOUND;
; 215  : 
; 216  : 		ObDereferenceObject(file);

  00260	48 8b 4d 67	 mov	 rcx, QWORD PTR file$[rbp-121]
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 217  : 		node = FindDevNodeRecurse(classObj, &node);

  0026a	48 89 7d 7f	 mov	 QWORD PTR node$[rbp-121], rdi

; 218  : 		if (node)

  0026e	48 85 ff	 test	 rdi, rdi
  00271	75 35		 jne	 SHORT $LN27@DriverEntr

; 219  : 			break;
; 220  : 
; 221  : 		*(u + MOU_STRING_INC) += 1;

  00273	66 ff 45 0f	 inc	 WORD PTR mouname$[rbp-81]
  00277	4c 8d 4d 77	 lea	 r9, QWORD PTR classObj$[rbp-121]

; 222  : 		mouId++;

  0027b	ff 05 00 00 00
	00		 inc	 DWORD PTR mouId
  00281	4c 8d 45 67	 lea	 r8, QWORD PTR file$[rbp-121]
  00285	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  0028a	48 8d 4d c7	 lea	 rcx, QWORD PTR classNameBuffer$[rbp-121]
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  00294	85 c0		 test	 eax, eax
  00296	74 c8		 je	 SHORT $LL2@DriverEntr
$LN28@DriverEntr:

; 248  : 			return STATUS_OBJECT_NAME_NOT_FOUND;

  00298	b8 34 00 00 c0	 mov	 eax, -1073741772	; ffffffffc0000034H

; 279  : }

  0029d	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  002a4	5f		 pop	 rdi
  002a5	5b		 pop	 rbx
  002a6	5d		 pop	 rbp
  002a7	c3		 ret	 0
$LN27@DriverEntr:

; 223  : 	}
; 224  : 
; 225  : 	mouTarget = classObj;

  002a8	48 8b 45 77	 mov	 rax, QWORD PTR classObj$[rbp-121]
  002ac	48 89 05 00 00
	00 00		 mov	 QWORD PTR mouTarget, rax

; 226  : 	classDrv = classObj->DriverObject;

  002b3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 227  : 
; 228  : 	MouClassReadRoutine = (MouclassRead)classDrv->MajorFunction[IRP_MJ_READ];

  002b7	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  002be	48 89 05 00 00
	00 00		 mov	 QWORD PTR MouClassReadRoutine, rax

; 229  : 
; 230  : 	classDrv->MajorFunction[IRP_MJ_READ] = ReadInstrumentation1;

  002c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ReadInstrumentation1
  002cc	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 231  : 
; 232  : 	DevObjExtension = input_mouse->DeviceObjectExtension;
; 233  : 	DevObjExtension->DeviceNode = (void*)node;

  002d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR input_mouse
  002da	48 8b 90 38 01
	00 00		 mov	 rdx, QWORD PTR [rax+312]
  002e1	48 8b 45 7f	 mov	 rax, QWORD PTR node$[rbp-121]
  002e5	48 89 42 28	 mov	 QWORD PTR [rdx+40], rax

; 234  : 
; 235  : 	MouseAddDevicePtr = (MouseAddDevice)classDrv->DriverExtension->AddDevice;
; 236  : 	MouseAddDevicePtr(classDrv, input_mouse);

  002e9	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  002ed	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR input_mouse
  002f4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr

; 237  : 
; 238  : 	//repeat same process for keyboard stacks
; 239  : 	RtlInitUnicodeString(&classNameBuffer, kbdname);

  002fe	48 8d 55 17	 lea	 rdx, QWORD PTR kbdname$[rbp-121]
  00302	48 8d 4d c7	 lea	 rcx, QWORD PTR classNameBuffer$[rbp-121]
  00306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 240  : 	u = kbdname;
; 241  : 
; 242  : 	charBuff = *(u + KBD_STRING_INC);

  0030c	0f b7 7d 41	 movzx	 edi, WORD PTR kbdname$[rbp-79]

; 243  : 
; 244  : 	while (1)
; 245  : 	{
; 246  : 		//run till we run out of devices or find a devnode
; 247  : 		if (IoGetDeviceObjectPointer(&classNameBuffer, FILE_ALL_ACCESS, &file, &classObj))

  00310	4c 8d 4d 77	 lea	 r9, QWORD PTR classObj$[rbp-121]
  00314	4c 8d 45 67	 lea	 r8, QWORD PTR file$[rbp-121]
  00318	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  0031d	48 8d 4d c7	 lea	 rcx, QWORD PTR classNameBuffer$[rbp-121]
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  00327	85 c0		 test	 eax, eax
  00329	0f 85 69 ff ff
	ff		 jne	 $LN28@DriverEntr
  0032f	48 8b 5d 67	 mov	 rbx, QWORD PTR $T2[rbp-121]
$LL4@DriverEntr:

; 249  : 
; 250  : 		ObDereferenceObject(file);

  00333	48 8b 4d 67	 mov	 rcx, QWORD PTR file$[rbp-121]
  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 251  : 
; 252  : 		node = FindDevNodeRecurse(classObj, &node);
; 253  : 		if (node)

  0033d	48 85 db	 test	 rbx, rbx
  00340	75 35		 jne	 SHORT $LN29@DriverEntr

; 254  : 			break;
; 255  : 
; 256  : 		*(u + KBD_STRING_INC) += 1;

  00342	66 ff 45 41	 inc	 WORD PTR kbdname$[rbp-79]
  00346	4c 8d 4d 77	 lea	 r9, QWORD PTR classObj$[rbp-121]

; 257  : 		kbdId++;

  0034a	ff 05 00 00 00
	00		 inc	 DWORD PTR kbdId
  00350	4c 8d 45 67	 lea	 r8, QWORD PTR file$[rbp-121]
  00354	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  00359	48 8d 4d c7	 lea	 rcx, QWORD PTR classNameBuffer$[rbp-121]
  0035d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer
  00363	85 c0		 test	 eax, eax
  00365	74 cc		 je	 SHORT $LL4@DriverEntr

; 248  : 			return STATUS_OBJECT_NAME_NOT_FOUND;

  00367	b8 34 00 00 c0	 mov	 eax, -1073741772	; ffffffffc0000034H

; 279  : }

  0036c	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00373	5f		 pop	 rdi
  00374	5b		 pop	 rbx
  00375	5d		 pop	 rbp
  00376	c3		 ret	 0
$LN29@DriverEntr:

; 258  : 	}
; 259  : 
; 260  : 	*(u + KBD_STRING_INC) = charBuff;
; 261  : 	kbdTarget = classObj;

  00377	48 8b 45 77	 mov	 rax, QWORD PTR classObj$[rbp-121]
  0037b	48 89 05 00 00
	00 00		 mov	 QWORD PTR kbdTarget, rax
  00382	66 89 7d 41	 mov	 WORD PTR kbdname$[rbp-79], di

; 262  : 	classDrv = classObj->DriverObject;

  00386	48 8b 78 08	 mov	 rdi, QWORD PTR [rax+8]

; 263  : 
; 264  : 	DevObjExtension = input_keyboard->DeviceObjectExtension;
; 265  : 	DevObjExtension->DeviceNode = (void*)node;

  0038a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR input_keyboard
  00391	48 8b 88 38 01
	00 00		 mov	 rcx, QWORD PTR [rax+312]
  00398	48 89 59 28	 mov	 QWORD PTR [rcx+40], rbx

; 266  : 
; 267  : 	KeyboardAddDevicePtr = (KeyboardAddDevice)classDrv->DriverExtension->AddDevice;
; 268  : 	KeyboardAddDevicePtr(classDrv, input_keyboard);

  0039c	48 8b cf	 mov	 rcx, rdi
  0039f	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  003a3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR input_keyboard
  003aa	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003ae	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr

; 269  : 
; 270  : 	KbdClassReadRoutine = (KbdclassRead)classDrv->MajorFunction[IRP_MJ_READ];

  003b4	48 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [rdi+136]

; 271  : 
; 272  : 	classDrv->MajorFunction[IRP_MJ_READ] = ReadInstrumentation;
; 273  : 
; 274  : 	for (i = 0; i<128; i++)
; 275  : 		KEY_DATA[i] = 0;
; 276  : 
; 277  : 	DbgPrintEx(0, 0, "Tsunami loaded.\n");

  003bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@KKPCHIIC@Tsunami?5loaded?4?6?$AA@FNODOBFM@
  003c2	48 89 05 00 00
	00 00		 mov	 QWORD PTR KbdClassReadRoutine, rax
  003c9	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  003ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ReadInstrumentation
  003d5	33 d2		 xor	 edx, edx
  003d7	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax
  003de	33 c0		 xor	 eax, eax
  003e0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:KEY_DATA
  003e7	f3 aa		 rep stosb
  003e9	33 c9		 xor	 ecx, ecx
  003eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DbgPrintEx

; 278  : 	return STATUS_SUCCESS;

  003f1	33 c0		 xor	 eax, eax

; 279  : }

  003f3	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  003fa	5f		 pop	 rdi
  003fb	5b		 pop	 rbx
  003fc	5d		 pop	 rbp
  003fd	c3		 ret	 0
DriverEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
;	COMDAT IoControl
_TEXT	SEGMENT
DeviceObject$ = 64
fill$1 = 72
Process$2 = 72
Status$ = 72
Process$3 = 72
Irp$ = 72
IoControl PROC						; COMDAT

; 82   : {

$LN17:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 83   : 	NTSTATUS Status;
; 84   : 	ULONG BytesIO = 0;
; 85   : 
; 86   : 	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
; 87   : 
; 88   : 	// Code received from user space
; 89   : 	ULONG ControlCode = stack->Parameters.DeviceIoControl.IoControlCode;

  0000a	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00011	48 8b f2	 mov	 rsi, rdx
  00014	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]

; 90   : 
; 91   : 	if (ControlCode == IO_READ_REQUEST)

  00017	81 f9 04 1c 22
	00		 cmp	 ecx, 2235396		; 00221c04H
  0001d	75 3c		 jne	 SHORT $LN2@IoControl

; 92   : 	{
; 93   : 		// Get the input buffer & format it to our struct
; 94   : 		PKERNEL_READ_REQUEST ReadInput = (PKERNEL_READ_REQUEST)Irp->AssociatedIrp.SystemBuffer;

  0001f	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]

; 95   : 		PKERNEL_READ_REQUEST ReadOutput = (PKERNEL_READ_REQUEST)Irp->AssociatedIrp.SystemBuffer;
; 96   : 
; 97   : 		PEPROCESS Process;
; 98   : 		// Get our process
; 99   : 		if (NT_SUCCESS(PsLookupProcessByProcessId(ReadInput->ProcessId, &Process)))

  00023	48 8d 54 24 48	 lea	 rdx, QWORD PTR Process$3[rsp]
  00028	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  00030	85 c0		 test	 eax, eax
  00032	78 5d		 js	 SHORT $LN7@IoControl

; 100  : 			KeReadVirtualMemory(Process, ReadInput->Address, &ReadInput->Response, ReadInput->Size);

  00034	44 8b 8b 10 20
	00 00		 mov	 r9d, DWORD PTR [rbx+8208]
  0003b	4c 8d 43 10	 lea	 r8, QWORD PTR [rbx+16]
  0003f	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00043	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Process$3[rsp]
  00048	e8 00 00 00 00	 call	 KeReadVirtualMemory

; 101  : 
; 102  : 		//DbgPrintEx(0, 0, "Read:  %lu, 0x%I64X, %lu \n", ReadInput->ProcessId, ReadInput->Address, ReadInput->Size);
; 103  : 
; 104  : 		Status = STATUS_SUCCESS;

  0004d	33 c0		 xor	 eax, eax
  0004f	8b d8		 mov	 ebx, eax

; 105  : 		BytesIO = sizeof(KERNEL_READ_REQUEST);

  00051	b8 18 20 00 00	 mov	 eax, 8216		; 00002018H

; 106  : 	}

  00056	e9 f7 00 00 00	 jmp	 $LN9@IoControl
$LN2@IoControl:

; 107  : 	else if (ControlCode == IO_WRITE_REQUEST)

  0005b	81 f9 08 1c 22
	00		 cmp	 ecx, 2235400		; 00221c08H
  00061	75 3c		 jne	 SHORT $LN5@IoControl

; 108  : 	{
; 109  : 		// Get the input buffer & format it to our struct
; 110  : 		PKERNEL_WRITE_REQUEST WriteInput = (PKERNEL_WRITE_REQUEST)Irp->AssociatedIrp.SystemBuffer;

  00063	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]

; 111  : 
; 112  : 		PEPROCESS Process;
; 113  : 		// Get our process
; 114  : 		if (NT_SUCCESS(PsLookupProcessByProcessId(WriteInput->ProcessId, &Process)))

  00067	48 8d 54 24 48	 lea	 rdx, QWORD PTR Process$2[rsp]
  0006c	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId
  00074	85 c0		 test	 eax, eax
  00076	78 19		 js	 SHORT $LN7@IoControl

; 115  : 			KeWriteVirtualMemory(Process, &WriteInput->Value, WriteInput->Address, WriteInput->Size);

  00078	44 8b 8b 10 20
	00 00		 mov	 r9d, DWORD PTR [rbx+8208]
  0007f	48 8d 53 10	 lea	 rdx, QWORD PTR [rbx+16]
  00083	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  00087	48 8b 4c 24 48	 mov	 rcx, QWORD PTR Process$2[rsp]
  0008c	e8 00 00 00 00	 call	 KeWriteVirtualMemory
$LN7@IoControl:

; 116  : 		//DbgPrintEx(0, 0, "ValW:  %lu \n", *(int*)WriteInput->Value);
; 117  : 		//DbgPrintEx(0, 0, "Write:  %lu, 0x%I64X \n", WriteInput->ProcessId, WriteInput->Address);
; 118  : 
; 119  : 		Status = STATUS_SUCCESS;

  00091	33 c0		 xor	 eax, eax
  00093	8b d8		 mov	 ebx, eax

; 120  : 		BytesIO = sizeof(KERNEL_WRITE_REQUEST);

  00095	b8 18 20 00 00	 mov	 eax, 8216		; 00002018H

; 121  : 	}

  0009a	e9 b3 00 00 00	 jmp	 $LN9@IoControl
$LN5@IoControl:

; 122  : 	else if (ControlCode == IO_MOUSE_REQUEST)

  0009f	81 f9 0c 1c 22
	00		 cmp	 ecx, 2235404		; 00221c0cH
  000a5	0f 85 a0 00 00
	00		 jne	 $LN8@IoControl

; 124  : 		PKERNEL_MOUSE_REQUEST mouseRequest = (PKERNEL_MOUSE_REQUEST)Irp->AssociatedIrp.SystemBuffer;

  000ab	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h

; 3415 : 	KeRaiseIrql(DISPATCH_LEVEL, &irql);

  000b0	b1 02		 mov	 cl, 2
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c

; 124  : 		PKERNEL_MOUSE_REQUEST mouseRequest = (PKERNEL_MOUSE_REQUEST)Irp->AssociatedIrp.SystemBuffer;

  000b2	48 8b 7a 18	 mov	 rdi, QWORD PTR [rdx+24]
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h

; 3407 : 	ULONG fill = 1;

  000b6	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR fill$1[rsp], 1
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c

; 125  : 		mdata.ButtonFlags |= mouseRequest->buttonCode;

  000be	0f b7 47 08	 movzx	 eax, WORD PTR [rdi+8]
  000c2	66 09 05 04 00
	00 00		 or	 WORD PTR mdata+4, ax

; 126  : 		mdata.LastY += mouseRequest->dy;

  000c9	8b 47 04	 mov	 eax, DWORD PTR [rdi+4]
  000cc	01 05 10 00 00
	00		 add	 DWORD PTR mdata+16, eax

; 127  : 		mdata.LastX += mouseRequest->dx;

  000d2	8b 07		 mov	 eax, DWORD PTR [rdi]
  000d4	01 05 0c 00 00
	00		 add	 DWORD PTR mdata+12, eax
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h

; 3412 : 	a1->UnitId = mouId;

  000da	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR mouId
  000e1	66 89 05 00 00
	00 00		 mov	 WORD PTR mdata, ax

; 3415 : 	KeRaiseIrql(DISPATCH_LEVEL, &irql);

  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KfRaiseIrql

; 3416 : 
; 3417 : 	MouseDpcRoutine(mouTarget, a1, (PMOUSE_INPUT_DATA)endptr, &fill);

  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mouTarget
  000f5	4c 8d 4c 24 48	 lea	 r9, QWORD PTR fill$1[rsp]
  000fa	0f b6 d8	 movzx	 ebx, al
  000fd	4c 8d 05 18 00
	00 00		 lea	 r8, OFFSET FLAT:mdata+24
  00104	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR MouseDpcRoutine
  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:mdata
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr

; 3418 : 
; 3419 : 	KeLowerIrql(irql);

  00118	0f b6 cb	 movzx	 ecx, bl
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeLowerIrql
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c

; 131  : 		mdata.ButtonFlags &= ~mouseRequest->buttonCode;

  00121	0f b7 47 08	 movzx	 eax, WORD PTR [rdi+8]

; 132  : 		mdata.LastY -= mouseRequest->dy;
; 133  : 		mdata.LastX -= mouseRequest->dx;
; 134  : 	}

  00125	8b 5c 24 48	 mov	 ebx, DWORD PTR Status$[rsp]
  00129	66 f7 d0	 not	 ax
  0012c	66 21 05 04 00
	00 00		 and	 WORD PTR mdata+4, ax
  00133	8b 47 04	 mov	 eax, DWORD PTR [rdi+4]
  00136	29 05 10 00 00
	00		 sub	 DWORD PTR mdata+16, eax
  0013c	8b 07		 mov	 eax, DWORD PTR [rdi]
  0013e	29 05 0c 00 00
	00		 sub	 DWORD PTR mdata+12, eax
  00144	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00149	eb 05		 jmp	 SHORT $LN15@IoControl
$LN8@IoControl:

; 135  : 	else
; 136  : 	{
; 137  : 		 // if the code is unknown
; 138  : 		Status = STATUS_INVALID_PARAMETER;

  0014b	bb 0d 00 00 c0	 mov	 ebx, -1073741811	; ffffffffc000000dH
$LN15@IoControl:

; 139  : 		BytesIO = 0;
; 140  : 	}
; 141  : 
; 142  : 	// Complete the request
; 143  : 	Irp->IoStatus.Status = Status;

  00150	33 c0		 xor	 eax, eax
$LN9@IoControl:

; 144  : 	Irp->IoStatus.Information = BytesIO;
; 145  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00152	33 d2		 xor	 edx, edx
  00154	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
  00157	48 8b ce	 mov	 rcx, rsi
  0015a	48 89 46 38	 mov	 QWORD PTR [rsi+56], rax
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 146  : 	
; 147  : 	return Status;

  00164	8b c3		 mov	 eax, ebx

; 148  : }

  00166	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0016b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016f	5e		 pop	 rsi
  00170	c3		 ret	 0
IoControl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
;	COMDAT KeWriteVirtualMemory
_TEXT	SEGMENT
Bytes$ = 64
Process$ = 96
SourceAddress$ = 104
TargetAddress$ = 112
Size$ = 120
KeWriteVirtualMemory PROC				; COMDAT

; 69   : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00015	49 8b d9	 mov	 rbx, r9
  00018	49 8b f8	 mov	 rdi, r8
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	4c 8b f1	 mov	 r14, rcx

; 70   : 	PSIZE_T Bytes;
; 71   : 	__try {
; 72   : 		MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, Process, TargetAddress, Size, KernelMode, &Bytes);

  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetCurrentProcess
  00027	48 8b c8	 mov	 rcx, rax
  0002a	48 8d 44 24 40	 lea	 rax, QWORD PTR Bytes$[rsp]
  0002f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00034	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00039	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0003e	4c 8b cf	 mov	 r9, rdi
  00041	4d 8b c6	 mov	 r8, r14
  00044	48 8b d6	 mov	 rdx, rsi
  00047	e8 00 00 00 00	 call	 MmCopyVirtualMemory

; 73   : 		return STATUS_SUCCESS;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN8@KeWriteVir
$LN6@KeWriteVir:

; 74   : 	}
; 75   : 	__except (EXCEPTION_EXECUTE_HANDLER) {
; 76   : 		return STATUS_ACCESS_DENIED;

  00050	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
$LN8@KeWriteVir:

; 77   : 	}
; 78   : }

  00055	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0005a	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0005f	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00064	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00068	41 5e		 pop	 r14
  0006a	c3		 ret	 0
KeWriteVirtualMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
;	COMDAT KeReadVirtualMemory
_TEXT	SEGMENT
Bytes$ = 64
Process$ = 96
SourceAddress$ = 104
TargetAddress$ = 112
Size$ = 120
KeReadVirtualMemory PROC				; COMDAT

; 56   : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00015	49 8b d9	 mov	 rbx, r9
  00018	49 8b f8	 mov	 rdi, r8
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	4c 8b f1	 mov	 r14, rcx

; 57   : 	PSIZE_T Bytes;
; 58   : 
; 59   : 	__try {
; 60   : 		MmCopyVirtualMemory(Process, SourceAddress, PsGetCurrentProcess(), TargetAddress, Size, KernelMode, &Bytes);

  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetCurrentProcess
  00027	4c 8b c0	 mov	 r8, rax
  0002a	48 8d 44 24 40	 lea	 rax, QWORD PTR Bytes$[rsp]
  0002f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00034	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00039	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0003e	4c 8b cf	 mov	 r9, rdi
  00041	48 8b d6	 mov	 rdx, rsi
  00044	49 8b ce	 mov	 rcx, r14
  00047	e8 00 00 00 00	 call	 MmCopyVirtualMemory

; 61   : 		return STATUS_SUCCESS;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN8@KeReadVirt
$LN6@KeReadVirt:

; 62   : 	}
; 63   : 	__except (EXCEPTION_EXECUTE_HANDLER) {
; 64   : 		return STATUS_ACCESS_DENIED;

  00050	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
$LN8@KeReadVirt:

; 65   : 	}
; 66   : }

  00055	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0005a	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0005f	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00064	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00068	41 5e		 pop	 r14
  0006a	c3		 ret	 0
KeReadVirtualMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
;	COMDAT CloseCall
_TEXT	SEGMENT
DeviceObject$ = 48
irp$ = 56
CloseCall PROC						; COMDAT

; 302  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 303  : 	irp->IoStatus.Status = STATUS_SUCCESS;

  00004	33 c9		 xor	 ecx, ecx
  00006	48 8b c2	 mov	 rax, rdx
  00009	89 4a 30	 mov	 DWORD PTR [rdx+48], ecx

; 304  : 	irp->IoStatus.Information = 0;

  0000c	48 89 4a 38	 mov	 QWORD PTR [rdx+56], rcx

; 305  : 
; 306  : 	IoCompleteRequest(irp, IO_NO_INCREMENT);

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 307  : 	return STATUS_SUCCESS;

  0001b	33 c0		 xor	 eax, eax

; 308  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
CloseCall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
;	COMDAT CreateCall
_TEXT	SEGMENT
DeviceObject$ = 48
irp$ = 56
CreateCall PROC						; COMDAT

; 293  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 294  : 	irp->IoStatus.Status = STATUS_SUCCESS;

  00004	33 c9		 xor	 ecx, ecx
  00006	48 8b c2	 mov	 rax, rdx
  00009	89 4a 30	 mov	 DWORD PTR [rdx+48], ecx

; 295  : 	irp->IoStatus.Information = 0;

  0000c	48 89 4a 38	 mov	 QWORD PTR [rdx+56], rcx

; 296  : 
; 297  : 	IoCompleteRequest(irp, IO_NO_INCREMENT);

  00010	33 d2		 xor	 edx, edx
  00012	48 8b c8	 mov	 rcx, rax
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 298  : 	return STATUS_SUCCESS;

  0001b	33 c0		 xor	 eax, eax

; 299  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
CreateCall ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\driver.c
;	COMDAT UnloadDriver
_TEXT	SEGMENT
pDriverObject$ = 48
UnloadDriver PROC					; COMDAT

; 282  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 283  : 	DbgPrintEx(0, 0, "Tsunami unload routine called.\n");

  00009	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CA@CJALLJND@Tsunami?5unload?5routine?5called?4?6?$AA@FNODOBFM@
  00010	33 c9		 xor	 ecx, ecx
  00012	33 d2		 xor	 edx, edx
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DbgPrintEx

; 284  : 
; 285  : 	IoDeleteDevice(input_mouse);

  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR input_mouse
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 286  : 	IoDeleteDevice(input_keyboard);

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR input_keyboard
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 287  : 
; 288  : 	IoDeleteSymbolicLink(&dos);

  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 289  : 	IoDeleteDevice(pDriverObject->DeviceObject);

  00041	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]

; 290  : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx

; 289  : 	IoDeleteDevice(pDriverObject->DeviceObject);

  0004a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_IoDeleteDevice
UnloadDriver ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT InternalIoctl
_TEXT	SEGMENT
device$ = 8
irp$ = 16
InternalIoctl PROC					; COMDAT
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h

; 30868:     return Irp->Tail.Overlay.CurrentStackLocation;

  00000	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h

; 3590 : 	if (ios->Parameters.DeviceIoControl.IoControlCode == MOUCLASS_CONNECT_REQUEST)

  00007	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0000a	81 f9 03 02 0f
	00		 cmp	 ecx, 983555		; 000f0203H
  00010	75 12		 jne	 SHORT $LN2@InternalIo

; 3591 : 	{
; 3592 : 		cd = ios->Parameters.DeviceIoControl.Type3InputBuffer;
; 3593 : 		MouseDpcRoutine = (MouseServiceDpc)cd->ClassService;

  00012	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00016	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 3599 : 	}
; 3600 : 	else
; 3601 : 	{
; 3602 : 		InvalidRequest(device, irp);
; 3603 : 	}
; 3604 : 
; 3605 : 	return STATUS_SUCCESS;
; 3606 : }

  0001a	33 c0		 xor	 eax, eax
  0001c	48 89 0d 00 00
	00 00		 mov	 QWORD PTR MouseDpcRoutine, rcx
  00023	c3		 ret	 0
$LN2@InternalIo:

; 3594 : 	}
; 3595 : 	else if (ios->Parameters.DeviceIoControl.IoControlCode == KBDCLASS_CONNECT_REQUEST)

  00024	81 f9 03 02 0b
	00		 cmp	 ecx, 721411		; 000b0203H
  0002a	75 0f		 jne	 SHORT $LN11@InternalIo

; 3596 : 	{
; 3597 : 		cd = ios->Parameters.DeviceIoControl.Type3InputBuffer;
; 3598 : 		KeyboardDpcRoutine = (KeyboardServiceDpc)cd->ClassService;

  0002c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00030	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00034	48 89 0d 00 00
	00 00		 mov	 QWORD PTR KeyboardDpcRoutine, rcx
$LN11@InternalIo:

; 3599 : 	}
; 3600 : 	else
; 3601 : 	{
; 3602 : 		InvalidRequest(device, irp);
; 3603 : 	}
; 3604 : 
; 3605 : 	return STATUS_SUCCESS;
; 3606 : }

  0003b	33 c0		 xor	 eax, eax
  0003d	c3		 ret	 0
InternalIoctl ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT InvalidRequest
_TEXT	SEGMENT
device$ = 8
irp$ = 16
InvalidRequest PROC					; COMDAT

; 3573 : 	return STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 3574 : }

  00002	c3		 ret	 0
InvalidRequest ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT ReadInstrumentation1
_TEXT	SEGMENT
device$ = 8
irp$ = 16
ReadInstrumentation1 PROC				; COMDAT

; 3556 : 	ULONGLONG *routine;
; 3557 : 	routine = (ULONGLONG*)irp;
; 3558 : 	routine += 0xb;
; 3559 : 
; 3560 : 	if (!MouseInputRoutine)

  00000	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR MouseInputRoutine, 0
  00008	75 0b		 jne	 SHORT $LN2@ReadInstru

; 3561 : 	{
; 3562 : 		MouseInputRoutine = (mouinput)*routine;

  0000a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000e	48 89 05 00 00
	00 00		 mov	 QWORD PTR MouseInputRoutine, rax
$LN2@ReadInstru:

; 3563 : 	}
; 3564 : 
; 3565 : 	*routine = (ULONGLONG)MouseApc;

  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:MouseApc
  0001c	48 89 42 58	 mov	 QWORD PTR [rdx+88], rax

; 3566 : 	mouIrp = (struct KEYBOARD_INPUT_DATA*)irp->UserBuffer;

  00020	48 8b 42 70	 mov	 rax, QWORD PTR [rdx+112]
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR mouIrp, rax

; 3567 : 
; 3568 : 	return MouClassReadRoutine(device, irp);

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR MouClassReadRoutine
  00032	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __guard_dispatch_icall_fptr
ReadInstrumentation1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT ReadInstrumentation
_TEXT	SEGMENT
device$ = 8
irp$ = 16
ReadInstrumentation PROC				; COMDAT

; 3539 : 	ULONGLONG *routine;
; 3540 : 	routine = (ULONGLONG*)irp;
; 3541 : 	routine += 0xb;
; 3542 : 
; 3543 : 	if (!KeyboardInputRoutine)

  00000	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR KeyboardInputRoutine, 0
  00008	75 0b		 jne	 SHORT $LN2@ReadInstru

; 3544 : 	{
; 3545 : 		KeyboardInputRoutine = (kbdinput)*routine;

  0000a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000e	48 89 05 00 00
	00 00		 mov	 QWORD PTR KeyboardInputRoutine, rax
$LN2@ReadInstru:

; 3546 : 	}
; 3547 : 
; 3548 : 	*routine = (ULONGLONG)KeyboardApc;

  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:KeyboardApc
  0001c	48 89 42 58	 mov	 QWORD PTR [rdx+88], rax

; 3549 : 	mjRead = (struct KEYBOARD_INPUT_DATA*)irp->UserBuffer;

  00020	48 8b 42 70	 mov	 rax, QWORD PTR [rdx+112]
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR mjRead, rax

; 3550 : 
; 3551 : 	return KbdClassReadRoutine(device, irp);

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KbdClassReadRoutine
  00032	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __guard_dispatch_icall_fptr
ReadInstrumentation ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT MouseApc
_TEXT	SEGMENT
a1$ = 64
a2$ = 72
a3$ = 80
a4$ = 88
a5$ = 96
MouseApc PROC						; COMDAT

; 3486 : {

$LN23:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3487 : 	if (mouIrp->ButtonFlags&MOUSE_LEFT_BUTTON_DOWN)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR mouIrp
  0000b	4c 8b d9	 mov	 r11, rcx
  0000e	44 0f b7 50 04	 movzx	 r10d, WORD PTR [rax+4]
  00013	41 f6 c2 01	 test	 r10b, 1
  00017	74 0c		 je	 SHORT $LN2@MouseApc

; 3488 : 	{
; 3489 : 		MOU_DATA[0] = 1;

  00019	c6 05 00 00 00
	00 01		 mov	 BYTE PTR MOU_DATA, 1

; 3490 : 	}

  00020	e9 8e 00 00 00	 jmp	 $LN20@MouseApc
$LN2@MouseApc:

; 3491 : 	else if (mouIrp->ButtonFlags&MOUSE_LEFT_BUTTON_UP)

  00025	41 f6 c2 02	 test	 r10b, 2
  00029	74 09		 je	 SHORT $LN4@MouseApc

; 3492 : 	{
; 3493 : 		MOU_DATA[0] = 0;

  0002b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR MOU_DATA, 0

; 3494 : 	}

  00032	eb 7f		 jmp	 SHORT $LN20@MouseApc
$LN4@MouseApc:

; 3495 : 	else if (mouIrp->ButtonFlags&MOUSE_RIGHT_BUTTON_DOWN)

  00034	41 f6 c2 04	 test	 r10b, 4
  00038	74 09		 je	 SHORT $LN6@MouseApc

; 3496 : 	{
; 3497 : 		MOU_DATA[1] = 1;

  0003a	c6 05 01 00 00
	00 01		 mov	 BYTE PTR MOU_DATA+1, 1

; 3498 : 	}

  00041	eb 70		 jmp	 SHORT $LN20@MouseApc
$LN6@MouseApc:

; 3499 : 	else if (mouIrp->ButtonFlags&MOUSE_RIGHT_BUTTON_UP)

  00043	41 f6 c2 08	 test	 r10b, 8
  00047	74 09		 je	 SHORT $LN8@MouseApc

; 3500 : 	{
; 3501 : 		MOU_DATA[1] = 0;

  00049	c6 05 01 00 00
	00 00		 mov	 BYTE PTR MOU_DATA+1, 0

; 3502 : 	}

  00050	eb 61		 jmp	 SHORT $LN20@MouseApc
$LN8@MouseApc:

; 3503 : 	else if (mouIrp->ButtonFlags&MOUSE_MIDDLE_BUTTON_DOWN)

  00052	41 f6 c2 10	 test	 r10b, 16
  00056	74 09		 je	 SHORT $LN10@MouseApc

; 3504 : 	{
; 3505 : 		MOU_DATA[2] = 1;

  00058	c6 05 02 00 00
	00 01		 mov	 BYTE PTR MOU_DATA+2, 1

; 3506 : 	}

  0005f	eb 52		 jmp	 SHORT $LN20@MouseApc
$LN10@MouseApc:

; 3507 : 	else if (mouIrp->ButtonFlags&MOUSE_MIDDLE_BUTTON_UP)

  00061	41 f6 c2 20	 test	 r10b, 32		; 00000020H
  00065	74 09		 je	 SHORT $LN12@MouseApc

; 3508 : 	{
; 3509 : 		MOU_DATA[2] = 0;

  00067	c6 05 02 00 00
	00 00		 mov	 BYTE PTR MOU_DATA+2, 0

; 3510 : 	}

  0006e	eb 43		 jmp	 SHORT $LN20@MouseApc
$LN12@MouseApc:

; 3511 : 	else if (mouIrp->ButtonFlags&MOUSE_BUTTON_4_DOWN)

  00070	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  00074	74 09		 je	 SHORT $LN14@MouseApc

; 3512 : 	{
; 3513 : 		MOU_DATA[3] = 1;

  00076	c6 05 03 00 00
	00 01		 mov	 BYTE PTR MOU_DATA+3, 1

; 3514 : 	}

  0007d	eb 34		 jmp	 SHORT $LN20@MouseApc
$LN14@MouseApc:

; 3515 : 	else if (mouIrp->ButtonFlags&MOUSE_BUTTON_4_UP)

  0007f	45 84 d2	 test	 r10b, r10b
  00082	79 09		 jns	 SHORT $LN16@MouseApc

; 3516 : 	{
; 3517 : 		MOU_DATA[3] = 0;

  00084	c6 05 03 00 00
	00 00		 mov	 BYTE PTR MOU_DATA+3, 0

; 3518 : 	}

  0008b	eb 26		 jmp	 SHORT $LN20@MouseApc
$LN16@MouseApc:

; 3519 : 	else if (mouIrp->ButtonFlags&MOUSE_BUTTON_5_DOWN)

  0008d	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00092	66 44 85 d0	 test	 r10w, ax
  00096	74 09		 je	 SHORT $LN18@MouseApc

; 3520 : 	{
; 3521 : 		MOU_DATA[4] = 1;

  00098	c6 05 04 00 00
	00 01		 mov	 BYTE PTR MOU_DATA+4, 1

; 3522 : 	}

  0009f	eb 12		 jmp	 SHORT $LN20@MouseApc
$LN18@MouseApc:

; 3523 : 	else if (mouIrp->ButtonFlags&MOUSE_BUTTON_5_UP)

  000a1	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  000a6	66 44 85 d0	 test	 r10w, ax
  000aa	74 07		 je	 SHORT $LN20@MouseApc

; 3524 : 	{
; 3525 : 		MOU_DATA[4] = 0;

  000ac	c6 05 04 00 00
	00 00		 mov	 BYTE PTR MOU_DATA+4, 0
$LN20@MouseApc:

; 3526 : 	}
; 3527 : 
; 3528 : 	return MouseInputRoutine(a1, a2, a3, a4, a5);

  000b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a5$[rsp]
  000b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR MouseInputRoutine
  000bf	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000c4	49 8b cb	 mov	 rcx, r11
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr

; 3529 : }

  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
MouseApc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT KeyboardApc
_TEXT	SEGMENT
a1$ = 64
a2$ = 72
a3$ = 80
a4$ = 88
a5$ = 96
KeyboardApc PROC					; COMDAT

; 3469 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3470 : 	unsigned char max = (unsigned char)mjRead->MakeCode;

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR mjRead
  0000d	48 8b d9	 mov	 rbx, rcx

; 3471 : 
; 3472 : 
; 3473 : 	if (!mjRead->Flags)

  00010	44 0f b7 58 04	 movzx	 r11d, WORD PTR [rax+4]
  00015	44 0f b6 50 02	 movzx	 r10d, BYTE PTR [rax+2]
  0001a	66 45 85 db	 test	 r11w, r11w
  0001e	75 13		 jne	 SHORT $LN2@KeyboardAp

; 3474 : 	{
; 3475 : 		KEY_DATA[(max)-1] = 1;

  00020	41 0f b6 c2	 movzx	 eax, r10b
  00024	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:KEY_DATA
  0002b	42 c6 44 10 ff
	01		 mov	 BYTE PTR [rax+r10-1], 1

; 3476 : 	}

  00031	eb 17		 jmp	 SHORT $LN4@KeyboardAp
$LN2@KeyboardAp:

; 3477 : 	else if (mjRead->Flags&KEY_BREAK)

  00033	41 f6 c3 01	 test	 r11b, 1
  00037	74 11		 je	 SHORT $LN4@KeyboardAp

; 3478 : 	{
; 3479 : 		KEY_DATA[(max)-1] = 0;

  00039	41 0f b6 c2	 movzx	 eax, r10b
  0003d	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:KEY_DATA
  00044	42 c6 44 10 ff
	00		 mov	 BYTE PTR [rax+r10-1], 0
$LN4@KeyboardAp:

; 3480 : 	}
; 3481 : 
; 3482 : 	return KeyboardInputRoutine(a1, a2, a3, a4, a5);

  0004a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a5$[rsp]
  0004f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KeyboardInputRoutine
  00056	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr

; 3483 : }

  00064	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
KeyboardApc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT FindDevNodeRecurse
_TEXT	SEGMENT
a1$ = 8
a2$ = 16
FindDevNodeRecurse PROC					; COMDAT

; 3443 : {

  00000	4c 8b c2	 mov	 r8, rdx
  00003	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL5@FindDevNod:

; 3444 : 	struct DEVOBJ_EXTENSION_FIX *attachment;
; 3445 : 	attachment = a1->DeviceObjectExtension;

  00010	48 8b 81 38 01
	00 00		 mov	 rax, QWORD PTR [rcx+312]

; 3446 : 
; 3447 : 	if ((!attachment->AttachedTo) && (!attachment->DeviceNode))

  00017	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0001b	48 85 c9	 test	 rcx, rcx
  0001e	75 06		 jne	 SHORT $LN11@FindDevNod
  00020	48 39 48 28	 cmp	 QWORD PTR [rax+40], rcx
  00024	74 11		 je	 SHORT $LN1@FindDevNod
$LN11@FindDevNod:

; 3448 : 		return;
; 3449 : 
; 3450 : 	if ((!attachment->DeviceNode) && (attachment->AttachedTo))

  00026	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0002a	48 85 d2	 test	 rdx, rdx
  0002d	75 05		 jne	 SHORT $LN3@FindDevNod
  0002f	48 85 c9	 test	 rcx, rcx
  00032	75 dc		 jne	 SHORT $LL5@FindDevNod
$LN3@FindDevNod:

; 3451 : 	{
; 3452 : 		FindDevNodeRecurse(attachment->AttachedTo, a2);
; 3453 : 		return;
; 3454 : 	}
; 3455 : 
; 3456 : 	*a2 = (ULONGLONG)attachment->DeviceNode;

  00034	49 89 10	 mov	 QWORD PTR [r8], rdx
$LN1@FindDevNod:

; 3457 : 	return;
; 3458 : }

  00037	c3		 ret	 0
FindDevNodeRecurse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT SynthesizeMouse
_TEXT	SEGMENT
fill$ = 64
a1$ = 64
SynthesizeMouse PROC					; COMDAT

; 3404 : {

$LN4:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3405 : 	KIRQL irql;
; 3406 : 	char *endptr;
; 3407 : 	ULONG fill = 1;
; 3408 : 
; 3409 : 	endptr = (char*)a1;
; 3410 : 	endptr += sizeof(MOUSE_INPUT_DATA);
; 3411 : 
; 3412 : 	a1->UnitId = mouId;

  0000a	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR mouId
  00011	48 8b f9	 mov	 rdi, rcx
  00014	66 89 01	 mov	 WORD PTR [rcx], ax

; 3413 : 
; 3414 : 	//huehuehue
; 3415 : 	KeRaiseIrql(DISPATCH_LEVEL, &irql);

  00017	b1 02		 mov	 cl, 2
  00019	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR fill$[rsp], 1
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KfRaiseIrql

; 3416 : 
; 3417 : 	MouseDpcRoutine(mouTarget, a1, (PMOUSE_INPUT_DATA)endptr, &fill);

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mouTarget
  0002e	4c 8d 47 18	 lea	 r8, QWORD PTR [rdi+24]
  00032	0f b6 d8	 movzx	 ebx, al
  00035	4c 8d 4c 24 40	 lea	 r9, QWORD PTR fill$[rsp]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR MouseDpcRoutine
  00041	48 8b d7	 mov	 rdx, rdi
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr

; 3418 : 
; 3419 : 	KeLowerIrql(irql);

  0004a	0f b6 cb	 movzx	 ecx, bl
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeLowerIrql

; 3420 : }

  00053	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
SynthesizeMouse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\w7\source\repos\tsunami\tsunami\ntos.h
;	COMDAT SynthesizeKeyboard
_TEXT	SEGMENT
fill$ = 64
a1$ = 64
SynthesizeKeyboard PROC					; COMDAT

; 3377 : {

$LN4:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3378 : 	KIRQL irql;
; 3379 : 	char *endptr;
; 3380 : 	ULONG fill = 1;
; 3381 : 
; 3382 : 	endptr = (char*)a1;
; 3383 : 	endptr += sizeof(KEYBOARD_INPUT_DATA);
; 3384 : 
; 3385 : 	a1->UnitId = kbdId;

  0000a	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR kbdId
  00011	48 8b f9	 mov	 rdi, rcx
  00014	66 89 01	 mov	 WORD PTR [rcx], ax

; 3386 : 
; 3387 : 	//huehuehue
; 3388 : 	KeRaiseIrql(DISPATCH_LEVEL, &irql);

  00017	b1 02		 mov	 cl, 2
  00019	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR fill$[rsp], 1
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KfRaiseIrql

; 3389 : 
; 3390 : 	KeyboardDpcRoutine(kbdTarget, a1, (PKEYBOARD_INPUT_DATA)endptr, &fill);

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR kbdTarget
  0002e	4c 8d 47 0c	 lea	 r8, QWORD PTR [rdi+12]
  00032	0f b6 d8	 movzx	 ebx, al
  00035	4c 8d 4c 24 40	 lea	 r9, QWORD PTR fill$[rsp]
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KeyboardDpcRoutine
  00041	48 8b d7	 mov	 rdx, rdi
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __guard_dispatch_icall_fptr

; 3391 : 
; 3392 : 	KeLowerIrql(irql);

  0004a	0f b6 cb	 movzx	 ecx, bl
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeLowerIrql

; 3393 : }

  00053	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
SynthesizeKeyboard ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h
;	COMDAT IoGetCurrentIrpStackLocation
_TEXT	SEGMENT
Irp$ = 8
IoGetCurrentIrpStackLocation PROC			; COMDAT

; 30867:     NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 30868:     return Irp->Tail.Overlay.CurrentStackLocation;

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 30869: }

  00007	c3		 ret	 0
IoGetCurrentIrpStackLocation ENDP
_TEXT	ENDS
END
